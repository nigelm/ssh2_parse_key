{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ssh2_parse_key Parses ssh2 public keys in either openssh or RFC4716/Secsh formats and converts to either format. At this point any attempt to work with private keys will raise an exception. Features Reads public keys of the following encryption types:- ssh-rsa ssh-dss ecdsa-sha2-nistp256 ssh-ed25519 Reads either Openssh or RFC4716 format public keys Can read input sets with either or both formats in Can output either format for any key Installation With pip : python3.6 -m pip install ssh2_parse_key Usage To use SSH2 Key Parsing in a project from ssh2_parse_key import Ssh2Key # although you can create the object from internal data the normal method # would be to use the parse() or parse_file() which return a list of Ssh2Key objects. # Ssh2Key objects are immutable. # Load one or more keys in either openssh or RFC4716 from a file keys = Ssh2Key . parse_file ( \"/path/to/public_key\" ) # alternatively data = Path ( \"/path/to/public_key\" ) . read_text () keys = Ssh2Key . parse ( data ) # now those keys can be dealt with... for public_key in keys : print ( f \"This is a { key . type } key\" ) print ( f \"It uses { key . encryption } encryption\" ) print ( f \"comment = { key . comment } \" ) print ( f \"subject = { key . subject } \" ) print ( \"RFC4716 format representation\" ) print ( key . rfc4716 ()) print ( \"OpenSSH representation\" ) print ( key . openssh ()) Credits The package is strongly based on the perl Parse::SSH2::PublicKey module. The class is built using Michael DeHaan's ClassForge object system. Development on the python version was done by Nigel Metheringham <nigelm@cpan.org>","title":"Overview"},{"location":"#ssh2_parse_key","text":"Parses ssh2 public keys in either openssh or RFC4716/Secsh formats and converts to either format. At this point any attempt to work with private keys will raise an exception.","title":"ssh2_parse_key"},{"location":"#features","text":"Reads public keys of the following encryption types:- ssh-rsa ssh-dss ecdsa-sha2-nistp256 ssh-ed25519 Reads either Openssh or RFC4716 format public keys Can read input sets with either or both formats in Can output either format for any key","title":"Features"},{"location":"#installation","text":"With pip : python3.6 -m pip install ssh2_parse_key","title":"Installation"},{"location":"#usage","text":"To use SSH2 Key Parsing in a project from ssh2_parse_key import Ssh2Key # although you can create the object from internal data the normal method # would be to use the parse() or parse_file() which return a list of Ssh2Key objects. # Ssh2Key objects are immutable. # Load one or more keys in either openssh or RFC4716 from a file keys = Ssh2Key . parse_file ( \"/path/to/public_key\" ) # alternatively data = Path ( \"/path/to/public_key\" ) . read_text () keys = Ssh2Key . parse ( data ) # now those keys can be dealt with... for public_key in keys : print ( f \"This is a { key . type } key\" ) print ( f \"It uses { key . encryption } encryption\" ) print ( f \"comment = { key . comment } \" ) print ( f \"subject = { key . subject } \" ) print ( \"RFC4716 format representation\" ) print ( key . rfc4716 ()) print ( \"OpenSSH representation\" ) print ( key . openssh ())","title":"Usage"},{"location":"#credits","text":"The package is strongly based on the perl Parse::SSH2::PublicKey module. The class is built using Michael DeHaan's ClassForge object system. Development on the python version was done by Nigel Metheringham <nigelm@cpan.org>","title":"Credits"},{"location":"changelog/","text":"Changelog All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning . [0.6.2] - 2020-10-16 Failed tag and docs generation fixed. No functional changes [0.5.0] - 2020-10-16 Swapped the classforge base classing to attrs Added a lot of additional type annotations to assist with attrs conversion - this also assists in the documentation markup, These needed to be carefully handled to make portable to python under travis. Aditionally the OrderedDict[str, str] annotation completely broke mkdocs/mkdocstrings. [0.4.0] - 2020-10-16 Packaging Switched to using poetry for development and release Updated the pre-commit pipeline, with some minor formatting reworks Switch to MkDocs for documentation, along with mkdocstrings for API documentation [0.3.x] - 2020-09-27 Fixed up documentation Added a few additional tests This is now reasonably presentable [0.2.x] - 2020-09-25 First release Documentation build CI and release automation [0.1.0] - 2020-05-07 First builds - never release on PyPI.","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#062-2020-10-16","text":"Failed tag and docs generation fixed. No functional changes","title":"[0.6.2]  - 2020-10-16"},{"location":"changelog/#050-2020-10-16","text":"Swapped the classforge base classing to attrs Added a lot of additional type annotations to assist with attrs conversion - this also assists in the documentation markup, These needed to be carefully handled to make portable to python under travis. Aditionally the OrderedDict[str, str] annotation completely broke mkdocs/mkdocstrings.","title":"[0.5.0]  - 2020-10-16"},{"location":"changelog/#040-2020-10-16","text":"","title":"[0.4.0]  - 2020-10-16"},{"location":"changelog/#packaging","text":"Switched to using poetry for development and release Updated the pre-commit pipeline, with some minor formatting reworks Switch to MkDocs for documentation, along with mkdocstrings for API documentation","title":"Packaging"},{"location":"changelog/#03x-2020-09-27","text":"Fixed up documentation Added a few additional tests This is now reasonably presentable","title":"[0.3.x]  - 2020-09-27"},{"location":"changelog/#02x-2020-09-25","text":"First release Documentation build CI and release automation","title":"[0.2.x]  - 2020-09-25"},{"location":"changelog/#010-2020-05-07","text":"First builds - never release on PyPI.","title":"[0.1.0]  - 2020-05-07"},{"location":"contributing/","text":"Contributing Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Report Bugs Report bugs at https://github.com/nigelm/ssh2_parse_key/issues . If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation ssh2_parse_key could always use more documentation, whether as part of the official docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback The best way to send feedback is to file an issue at https://github.com/nigelm/ssh2_parse_key/issues . If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Get Started! Ready to contribute? Here's how to set up ssh2_parse_key for local development. Fork the ssh2_parse_key repo on GitHub. Clone your fork locally:: $ git clone git@github.com :your_name_here/ssh2_parse_key.git We use poetry for development, this is how you set up your fork for local development $ cd ssh2_parse_key/ $ poetry install Create a branch for local development:: $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, use pre-commit to do basic checks and ensure formatting is consitant, and check that your changes pass the tests:: $ pre-commit run $ poetry run pytest $ poetry run make docs # generate local docs for checking pre-commit may need to be installed onto your system. Commit your changes and push your branch to GitHub:: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website. Deploying A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in HISTORY.rst). Then run:: $ bump2version patch # possible: major / minor / patch $ git push $ git push --tags Travis will then deploy to PyPI if tests pass.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"contributing/#report-bugs","text":"Report bugs at https://github.com/nigelm/ssh2_parse_key/issues . If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug.","title":"Report Bugs"},{"location":"contributing/#fix-bugs","text":"Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.","title":"Fix Bugs"},{"location":"contributing/#implement-features","text":"Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.","title":"Implement Features"},{"location":"contributing/#write-documentation","text":"ssh2_parse_key could always use more documentation, whether as part of the official docs, in docstrings, or even on the web in blog posts, articles, and such.","title":"Write Documentation"},{"location":"contributing/#submit-feedback","text":"The best way to send feedback is to file an issue at https://github.com/nigelm/ssh2_parse_key/issues . If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Submit Feedback"},{"location":"contributing/#get-started","text":"Ready to contribute? Here's how to set up ssh2_parse_key for local development. Fork the ssh2_parse_key repo on GitHub. Clone your fork locally:: $ git clone git@github.com :your_name_here/ssh2_parse_key.git We use poetry for development, this is how you set up your fork for local development $ cd ssh2_parse_key/ $ poetry install Create a branch for local development:: $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, use pre-commit to do basic checks and ensure formatting is consitant, and check that your changes pass the tests:: $ pre-commit run $ poetry run pytest $ poetry run make docs # generate local docs for checking pre-commit may need to be installed onto your system. Commit your changes and push your branch to GitHub:: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website.","title":"Get Started!"},{"location":"contributing/#deploying","text":"A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in HISTORY.rst). Then run:: $ bump2version patch # possible: major / minor / patch $ git push $ git push --tags Travis will then deploy to PyPI if tests pass.","title":"Deploying"},{"location":"library/","text":"Library The library defines a single class Ssh2Key() in the ssh2_parse_key module: Main module for ssh2_parse_key - provides Ssh2Key() Ssh2Key Encapsulates an ssh public key An Ssh2Key object is immutable after creation. Typically you would create Ssh2Key objects by using parse() or parse_file() class methods. Attributes: Name Type Description key str The ssh key itself, Base64 string type str one of public or private encryption str one of ssh-rsa , ssh-dss , ecdsa-sha2-nistp256 , ssh-ed25519 headers Any headers for the key - eg Comment. __delattr__ ( self , name ) special Attached to frozen classes as delattr . Source code in ssh2_parse_key/ssh2_parse_key.py def _frozen_delattrs ( self , name ): \"\"\" Attached to frozen classes as __delattr__. \"\"\" raise FrozenInstanceError () __eq__ ( self , other ) special Method generated by attrs for class Ssh2Key. Source code in ssh2_parse_key/ssh2_parse_key.py def __eq__ ( self , other ): if other . __class__ is not self . __class__ : return NotImplemented return ( self . key , self . type , self . encryption , self . headers , ) == ( other . key , other . type , other . encryption , other . headers , ) __ge__ ( self , other ) special Method generated by attrs for class Ssh2Key. Source code in ssh2_parse_key/ssh2_parse_key.py def __ge__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) >= attrs_to_tuple ( other ) return NotImplemented __getstate__ ( self ) special Automatically created by attrs. Source code in ssh2_parse_key/ssh2_parse_key.py def slots_getstate ( self ): \"\"\" Automatically created by attrs. \"\"\" return tuple ( getattr ( self , name ) for name in state_attr_names ) __gt__ ( self , other ) special Method generated by attrs for class Ssh2Key. Source code in ssh2_parse_key/ssh2_parse_key.py def __gt__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) > attrs_to_tuple ( other ) return NotImplemented __hash__ ( self ) special Method generated by attrs for class Ssh2Key. Source code in ssh2_parse_key/ssh2_parse_key.py def __hash__ ( self ): return hash (( - 5741410198400567549 , self . key , self . type , self . encryption , self . headers , )) __init__ ( self , * , key , type = 'public' , encryption = 'ssh-rsa' , headers = NOTHING ) special Method generated by attrs for class Ssh2Key. Source code in ssh2_parse_key/ssh2_parse_key.py def __init__ ( self , * , key , type = attr_dict [ 'type' ] . default , encryption = attr_dict [ 'encryption' ] . default , headers = NOTHING ): _setattr = _cached_setattr . __get__ ( self , self . __class__ ) _setattr ( 'key' , key ) _setattr ( 'type' , type ) _setattr ( 'encryption' , encryption ) if headers is not NOTHING : _setattr ( 'headers' , headers ) else : _setattr ( 'headers' , __attr_factory_headers ()) if _config . _run_validators is True : __attr_validator_type ( self , __attr_type , self . type ) __attr_validator_encryption ( self , __attr_encryption , self . encryption ) __le__ ( self , other ) special Method generated by attrs for class Ssh2Key. Source code in ssh2_parse_key/ssh2_parse_key.py def __le__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) <= attrs_to_tuple ( other ) return NotImplemented __lt__ ( self , other ) special Method generated by attrs for class Ssh2Key. Source code in ssh2_parse_key/ssh2_parse_key.py def __lt__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) < attrs_to_tuple ( other ) return NotImplemented __ne__ ( self , other ) special Method generated by attrs for class Ssh2Key. Source code in ssh2_parse_key/ssh2_parse_key.py def __ne__ ( self , other ): \"\"\" Check equality and either forward a NotImplemented or return the result negated. \"\"\" result = self . __eq__ ( other ) if result is NotImplemented : return NotImplemented return not result __repr__ ( self ) special Method generated by attrs for class Ssh2Key. Source code in ssh2_parse_key/ssh2_parse_key.py def __repr__ ( self ): \"\"\" Automatically created by attrs. \"\"\" try : working_set = _already_repring . working_set except AttributeError : working_set = set () _already_repring . working_set = working_set if id ( self ) in working_set : return \"...\" real_cls = self . __class__ if ns is None : qualname = getattr ( real_cls , \"__qualname__\" , None ) if qualname is not None : class_name = qualname . rsplit ( \">.\" , 1 )[ - 1 ] else : class_name = real_cls . __name__ else : class_name = ns + \".\" + real_cls . __name__ # Since 'self' remains on the stack (i.e.: strongly referenced) for the # duration of this call, it's safe to depend on id(...) stability, and # not need to track the instance and therefore worry about properties # like weakref- or hash-ability. working_set . add ( id ( self )) try : result = [ class_name , \"(\" ] first = True for name , attr_repr in attr_names_with_reprs : if first : first = False else : result . append ( \", \" ) result . extend ( ( name , \"=\" , attr_repr ( getattr ( self , name , NOTHING ))) ) return \"\" . join ( result ) + \")\" finally : working_set . remove ( id ( self )) __setattr__ ( self , name , value ) special Attached to frozen classes as setattr . Source code in ssh2_parse_key/ssh2_parse_key.py def _frozen_setattrs ( self , name , value ): \"\"\" Attached to frozen classes as __setattr__. \"\"\" raise FrozenInstanceError () __setstate__ ( self , state ) special Automatically created by attrs. Source code in ssh2_parse_key/ssh2_parse_key.py def slots_setstate ( self , state ): \"\"\" Automatically created by attrs. \"\"\" __bound_setattr = _obj_setattr . __get__ ( self , Attribute ) for name , value in zip ( state_attr_names , state ): __bound_setattr ( name , value ) # The hash code cache is not included when the object is # serialized, but it still needs to be initialized to None to # indicate that the first call to __hash__ should be a cache # miss. if hash_caching_enabled : __bound_setattr ( _hash_cache_field , None ) comment ( self ) Returns the comment header from a ssh key object. Returns: Type Description str string: Comment field or an empty string. Source code in ssh2_parse_key/ssh2_parse_key.py def comment ( self ) -> str : \"\"\" Returns the comment header from a ssh key object. Arguments: Returns: string: Comment field or an empty string. \"\"\" if \"Comment\" in self . headers : return self . headers [ \"Comment\" ] else : return \"\" openssh ( self ) Returns an SSH public/private key in OpenSSH format. Preserves 'comment' field parsed from either SECSH or OpenSSH. Returned as a single string including newlines and with terminating newline. Exceptions: Type Description ValueError Unable to output openssh format private keys Returns: Type Description str string: Single openssh key as a string including newlines and with terminating newline. Source code in ssh2_parse_key/ssh2_parse_key.py def openssh ( self ) -> str : \"\"\" Returns an SSH public/private key in OpenSSH format. Preserves 'comment' field parsed from either SECSH or OpenSSH. Returned as a single string including newlines and with terminating newline. Arguments: Raises: ValueError: Unable to output openssh format private keys Returns: string: Single openssh key as a string including newlines and with terminating newline. \"\"\" lines : \"List[str]\" = [] if self . type == \"public\" : lines . append ( \" \" . join ([ self . encryption , self . key , self . comment ()])) else : # ## Initial code to deal with private keys not used # # private key - obviously! # # add the wrapping header # lines.append(f\"---- BEGIN {self.encryption} PRIVATE KEY ----\") # # # add the headers, if any # if len(self.headers): # for header, value in self.headers.items(): # self._encode_header(lines, header, value, 64) # # # add the key content # lines.extend(textwrap.wrap(self.key, 64)) # # # add the wrapping footer # lines.append(f\"---- END {self.encryption} PRIVATE KEY ----\") raise ValueError ( \"Unable to output openssh format private keys\" ) lines . append ( \"\" ) # force terminating newline # return the assembled string return \" \\n \" . join ( lines ) parse ( data ) classmethod Creates a set of Ssh2Key objects from a string of ssh key data Accepts a block of text containing SSH2 public keys (in either OpenSSH or SECSH format) and parses out SSH2 public keys returning them as Ssh2Key Objects. Parameters: Name Type Description Default data str A multiline string of ssh key data in OpenSSH or SECSH format required Exceptions: Type Description ValueError Unrecognised type of ssh key ValueError No valid ssh keys found Returns: Type Description List[Ssh2Key] keys: A list of Ssh2Key objects Source code in ssh2_parse_key/ssh2_parse_key.py @classmethod def parse ( cls , data : str ) -> \"List[Ssh2Key]\" : \"\"\" Creates a set of `Ssh2Key` objects from a string of ssh key data Accepts a block of text containing SSH2 public keys (in either OpenSSH or SECSH format) and parses out SSH2 public keys returning them as `Ssh2Key` Objects. Arguments: data: A multiline string of ssh key data in OpenSSH or SECSH format Raises: ValueError: Unrecognised type of ssh key ValueError: No valid ssh keys found Returns: keys: A list of `Ssh2Key` objects \"\"\" lines = data . splitlines () # break the input into lines keys : \"List[Ssh2Key]\" = [] inside_keyblock = False # where we are keyblock : \"List[str]\" = [] keytype = \"\" pubpriv = \"\" for line in lines : matches = KEY_BOUNDARY_PATTERN . match ( line ) if inside_keyblock and matches and matches . group ( \"beginend\" ) == \"END\" : inside_keyblock = False # no longer within a keyblock if keytype == matches . group ( \"keytype\" ) and pubpriv == matches . group ( \"pubpriv\" , ): if keytype in [ \"OPENSSH\" , \"DSA\" , \"EC\" , \"RSA\" ]: key = cls . _parse_openssh ( keyblock , keytype , pubpriv ) elif keytype == \"SSH2\" : key = cls . _parse_secsh ( keyblock , pubpriv ) else : raise ValueError ( f \"Unrecognised type of ssh key { keytype } \" , ) if key : keys . append ( key ) elif inside_keyblock : keyblock . append ( line ) elif matches and matches . group ( \"beginend\" ) == \"BEGIN\" : keytype = matches . group ( \"keytype\" ) pubpriv = matches . group ( \"pubpriv\" ) inside_keyblock = True # inside a new keyblock else : # check for OpenSSH format -- all on one line matches = OPENSSH_PUBKEY_PATTERN . match ( line ) if matches : keys . append ( cls . _parse_openssh_oneline ( matches )) else : # raise ValueError(\"Unrecognised type of ssh key\") pass # ignore for now if len ( keys ) == 0 : raise ValueError ( \"No valid ssh keys found\" ) # return the assemblage of keys return keys parse_file ( filepath ) classmethod Creates a set of Ssh2Key objects from a file of ssh key data Accepts a block of text containing SSH2 public keys (in either OpenSSH or SECSH format) and parses out SSH2 public keys returning them as Ssh2Key Objects. Parameters: Name Type Description Default filepath PathLike[str] Pathname of a file of ssh key data in OpenSSH or SECSH format required Exceptions: Type Description IOError From underlying open/read ValueError Unrecognised type of ssh key ValueError No valid ssh keys found Returns: Type Description List[Ssh2Key] keys: A list of Ssh2Key objects Source code in ssh2_parse_key/ssh2_parse_key.py @classmethod def parse_file ( cls , filepath : \"PathLike[str]\" ) -> \"List[Ssh2Key]\" : \"\"\" Creates a set of `Ssh2Key` objects from a file of ssh key data Accepts a block of text containing SSH2 public keys (in either OpenSSH or SECSH format) and parses out SSH2 public keys returning them as `Ssh2Key` Objects. Arguments: filepath: Pathname of a file of ssh key data in OpenSSH or SECSH format Raises: IOError: From underlying open/read ValueError: Unrecognised type of ssh key ValueError: No valid ssh keys found Returns: keys: A list of `Ssh2Key` objects \"\"\" with open ( filepath ) as f : data = f . read () return cls . parse ( data ) rfc4716 ( self ) Returns an SSH public key in SECSH format (as specified in RFC4716). Preserves headers and the order of headers. Returned as a single string including newlines and with terminating newline. Alias - rfc4716() just calls secsh() See http://tools.ietf.org/html/rfc4716 Exceptions: Type Description ValueError Unable to output secsh format private keys Returns: Type Description str string: Single secsh key as a string including newlines and with terminating newline. Source code in ssh2_parse_key/ssh2_parse_key.py def rfc4716 ( self ) -> str : \"\"\" Returns an SSH public key in SECSH format (as specified in RFC4716). Preserves headers and the order of headers. Returned as a single string including newlines and with terminating newline. Alias - ``rfc4716()`` just calls ``secsh()`` See http://tools.ietf.org/html/rfc4716 Arguments: Raises: ValueError: Unable to output secsh format private keys Returns: string: Single secsh key as a string including newlines and with terminating newline. \"\"\" return self . secsh () secsh ( self ) Returns an SSH public key in SECSH format (as specified in RFC4716). Preserves headers and the order of headers. Returned as a single string including newlines and with terminating newline. See http://tools.ietf.org/html/rfc4716 Exceptions: Type Description ValueError Unable to output secsh format private keys Returns: Type Description str string: Single secsh key as a string including newlines and with terminating newline. Source code in ssh2_parse_key/ssh2_parse_key.py def secsh ( self ) -> str : \"\"\" Returns an SSH public key in SECSH format (as specified in RFC4716). Preserves headers and the order of headers. Returned as a single string including newlines and with terminating newline. See http://tools.ietf.org/html/rfc4716 Arguments: Raises: ValueError: Unable to output secsh format private keys Returns: string: Single secsh key as a string including newlines and with terminating newline. \"\"\" lines : \"List[str]\" = [] if self . type == \"public\" : key_header_chunk = \"SSH2 PUBLIC KEY\" else : raise ValueError ( \"Unable to output secsh format private keys\" ) key_header_chunk = \"SSH2 ENCRYPTED PRIVATE KEY\" # add the wrapping header lines . append ( f \"---- BEGIN { key_header_chunk } ----\" ) # add the headers, if any if len ( self . headers ): for header , value in self . headers . items (): self . _encode_header ( lines , header , value , 74 ) # add the key content lines . extend ( textwrap . wrap ( self . key , 70 )) # add the wrapping footer lines . append ( f \"---- END { key_header_chunk } ----\" ) lines . append ( \"\" ) # force terminating newline # return the assembled string return \" \\n \" . join ( lines ) subject ( self ) Returns the subject header from a ssh key object. Returns: Type Description Union[str, None] string: Subject field or None . Source code in ssh2_parse_key/ssh2_parse_key.py def subject ( self ) -> \"typing.Union[str, None]\" : \"\"\" Returns the subject header from a ssh key object. Arguments: Returns: string: Subject field or `None`. \"\"\" if \"Subject\" in self . headers : return self . headers [ \"Subject\" ] return None","title":"API Reference"},{"location":"library/#library","text":"The library defines a single class Ssh2Key() in the ssh2_parse_key module:","title":"Library"},{"location":"library/#ssh2_parse_key.ssh2_parse_key","text":"Main module for ssh2_parse_key - provides Ssh2Key()","title":"ssh2_parse_key.ssh2_parse_key"},{"location":"library/#ssh2_parse_key.ssh2_parse_key.Ssh2Key","text":"Encapsulates an ssh public key An Ssh2Key object is immutable after creation. Typically you would create Ssh2Key objects by using parse() or parse_file() class methods. Attributes: Name Type Description key str The ssh key itself, Base64 string type str one of public or private encryption str one of ssh-rsa , ssh-dss , ecdsa-sha2-nistp256 , ssh-ed25519 headers Any headers for the key - eg Comment.","title":"Ssh2Key"},{"location":"library/#ssh2_parse_key.ssh2_parse_key.Ssh2Key.__delattr__","text":"Attached to frozen classes as delattr . Source code in ssh2_parse_key/ssh2_parse_key.py def _frozen_delattrs ( self , name ): \"\"\" Attached to frozen classes as __delattr__. \"\"\" raise FrozenInstanceError ()","title":"__delattr__()"},{"location":"library/#ssh2_parse_key.ssh2_parse_key.Ssh2Key.__eq__","text":"Method generated by attrs for class Ssh2Key. Source code in ssh2_parse_key/ssh2_parse_key.py def __eq__ ( self , other ): if other . __class__ is not self . __class__ : return NotImplemented return ( self . key , self . type , self . encryption , self . headers , ) == ( other . key , other . type , other . encryption , other . headers , )","title":"__eq__()"},{"location":"library/#ssh2_parse_key.ssh2_parse_key.Ssh2Key.__ge__","text":"Method generated by attrs for class Ssh2Key. Source code in ssh2_parse_key/ssh2_parse_key.py def __ge__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) >= attrs_to_tuple ( other ) return NotImplemented","title":"__ge__()"},{"location":"library/#ssh2_parse_key.ssh2_parse_key.Ssh2Key.__getstate__","text":"Automatically created by attrs. Source code in ssh2_parse_key/ssh2_parse_key.py def slots_getstate ( self ): \"\"\" Automatically created by attrs. \"\"\" return tuple ( getattr ( self , name ) for name in state_attr_names )","title":"__getstate__()"},{"location":"library/#ssh2_parse_key.ssh2_parse_key.Ssh2Key.__gt__","text":"Method generated by attrs for class Ssh2Key. Source code in ssh2_parse_key/ssh2_parse_key.py def __gt__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) > attrs_to_tuple ( other ) return NotImplemented","title":"__gt__()"},{"location":"library/#ssh2_parse_key.ssh2_parse_key.Ssh2Key.__hash__","text":"Method generated by attrs for class Ssh2Key. Source code in ssh2_parse_key/ssh2_parse_key.py def __hash__ ( self ): return hash (( - 5741410198400567549 , self . key , self . type , self . encryption , self . headers , ))","title":"__hash__()"},{"location":"library/#ssh2_parse_key.ssh2_parse_key.Ssh2Key.__init__","text":"Method generated by attrs for class Ssh2Key. Source code in ssh2_parse_key/ssh2_parse_key.py def __init__ ( self , * , key , type = attr_dict [ 'type' ] . default , encryption = attr_dict [ 'encryption' ] . default , headers = NOTHING ): _setattr = _cached_setattr . __get__ ( self , self . __class__ ) _setattr ( 'key' , key ) _setattr ( 'type' , type ) _setattr ( 'encryption' , encryption ) if headers is not NOTHING : _setattr ( 'headers' , headers ) else : _setattr ( 'headers' , __attr_factory_headers ()) if _config . _run_validators is True : __attr_validator_type ( self , __attr_type , self . type ) __attr_validator_encryption ( self , __attr_encryption , self . encryption )","title":"__init__()"},{"location":"library/#ssh2_parse_key.ssh2_parse_key.Ssh2Key.__le__","text":"Method generated by attrs for class Ssh2Key. Source code in ssh2_parse_key/ssh2_parse_key.py def __le__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) <= attrs_to_tuple ( other ) return NotImplemented","title":"__le__()"},{"location":"library/#ssh2_parse_key.ssh2_parse_key.Ssh2Key.__lt__","text":"Method generated by attrs for class Ssh2Key. Source code in ssh2_parse_key/ssh2_parse_key.py def __lt__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) < attrs_to_tuple ( other ) return NotImplemented","title":"__lt__()"},{"location":"library/#ssh2_parse_key.ssh2_parse_key.Ssh2Key.__ne__","text":"Method generated by attrs for class Ssh2Key. Source code in ssh2_parse_key/ssh2_parse_key.py def __ne__ ( self , other ): \"\"\" Check equality and either forward a NotImplemented or return the result negated. \"\"\" result = self . __eq__ ( other ) if result is NotImplemented : return NotImplemented return not result","title":"__ne__()"},{"location":"library/#ssh2_parse_key.ssh2_parse_key.Ssh2Key.__repr__","text":"Method generated by attrs for class Ssh2Key. Source code in ssh2_parse_key/ssh2_parse_key.py def __repr__ ( self ): \"\"\" Automatically created by attrs. \"\"\" try : working_set = _already_repring . working_set except AttributeError : working_set = set () _already_repring . working_set = working_set if id ( self ) in working_set : return \"...\" real_cls = self . __class__ if ns is None : qualname = getattr ( real_cls , \"__qualname__\" , None ) if qualname is not None : class_name = qualname . rsplit ( \">.\" , 1 )[ - 1 ] else : class_name = real_cls . __name__ else : class_name = ns + \".\" + real_cls . __name__ # Since 'self' remains on the stack (i.e.: strongly referenced) for the # duration of this call, it's safe to depend on id(...) stability, and # not need to track the instance and therefore worry about properties # like weakref- or hash-ability. working_set . add ( id ( self )) try : result = [ class_name , \"(\" ] first = True for name , attr_repr in attr_names_with_reprs : if first : first = False else : result . append ( \", \" ) result . extend ( ( name , \"=\" , attr_repr ( getattr ( self , name , NOTHING ))) ) return \"\" . join ( result ) + \")\" finally : working_set . remove ( id ( self ))","title":"__repr__()"},{"location":"library/#ssh2_parse_key.ssh2_parse_key.Ssh2Key.__setattr__","text":"Attached to frozen classes as setattr . Source code in ssh2_parse_key/ssh2_parse_key.py def _frozen_setattrs ( self , name , value ): \"\"\" Attached to frozen classes as __setattr__. \"\"\" raise FrozenInstanceError ()","title":"__setattr__()"},{"location":"library/#ssh2_parse_key.ssh2_parse_key.Ssh2Key.__setstate__","text":"Automatically created by attrs. Source code in ssh2_parse_key/ssh2_parse_key.py def slots_setstate ( self , state ): \"\"\" Automatically created by attrs. \"\"\" __bound_setattr = _obj_setattr . __get__ ( self , Attribute ) for name , value in zip ( state_attr_names , state ): __bound_setattr ( name , value ) # The hash code cache is not included when the object is # serialized, but it still needs to be initialized to None to # indicate that the first call to __hash__ should be a cache # miss. if hash_caching_enabled : __bound_setattr ( _hash_cache_field , None )","title":"__setstate__()"},{"location":"library/#ssh2_parse_key.ssh2_parse_key.Ssh2Key.comment","text":"Returns the comment header from a ssh key object. Returns: Type Description str string: Comment field or an empty string. Source code in ssh2_parse_key/ssh2_parse_key.py def comment ( self ) -> str : \"\"\" Returns the comment header from a ssh key object. Arguments: Returns: string: Comment field or an empty string. \"\"\" if \"Comment\" in self . headers : return self . headers [ \"Comment\" ] else : return \"\"","title":"comment()"},{"location":"library/#ssh2_parse_key.ssh2_parse_key.Ssh2Key.openssh","text":"Returns an SSH public/private key in OpenSSH format. Preserves 'comment' field parsed from either SECSH or OpenSSH. Returned as a single string including newlines and with terminating newline. Exceptions: Type Description ValueError Unable to output openssh format private keys Returns: Type Description str string: Single openssh key as a string including newlines and with terminating newline. Source code in ssh2_parse_key/ssh2_parse_key.py def openssh ( self ) -> str : \"\"\" Returns an SSH public/private key in OpenSSH format. Preserves 'comment' field parsed from either SECSH or OpenSSH. Returned as a single string including newlines and with terminating newline. Arguments: Raises: ValueError: Unable to output openssh format private keys Returns: string: Single openssh key as a string including newlines and with terminating newline. \"\"\" lines : \"List[str]\" = [] if self . type == \"public\" : lines . append ( \" \" . join ([ self . encryption , self . key , self . comment ()])) else : # ## Initial code to deal with private keys not used # # private key - obviously! # # add the wrapping header # lines.append(f\"---- BEGIN {self.encryption} PRIVATE KEY ----\") # # # add the headers, if any # if len(self.headers): # for header, value in self.headers.items(): # self._encode_header(lines, header, value, 64) # # # add the key content # lines.extend(textwrap.wrap(self.key, 64)) # # # add the wrapping footer # lines.append(f\"---- END {self.encryption} PRIVATE KEY ----\") raise ValueError ( \"Unable to output openssh format private keys\" ) lines . append ( \"\" ) # force terminating newline # return the assembled string return \" \\n \" . join ( lines )","title":"openssh()"},{"location":"library/#ssh2_parse_key.ssh2_parse_key.Ssh2Key.parse","text":"Creates a set of Ssh2Key objects from a string of ssh key data Accepts a block of text containing SSH2 public keys (in either OpenSSH or SECSH format) and parses out SSH2 public keys returning them as Ssh2Key Objects. Parameters: Name Type Description Default data str A multiline string of ssh key data in OpenSSH or SECSH format required Exceptions: Type Description ValueError Unrecognised type of ssh key ValueError No valid ssh keys found Returns: Type Description List[Ssh2Key] keys: A list of Ssh2Key objects Source code in ssh2_parse_key/ssh2_parse_key.py @classmethod def parse ( cls , data : str ) -> \"List[Ssh2Key]\" : \"\"\" Creates a set of `Ssh2Key` objects from a string of ssh key data Accepts a block of text containing SSH2 public keys (in either OpenSSH or SECSH format) and parses out SSH2 public keys returning them as `Ssh2Key` Objects. Arguments: data: A multiline string of ssh key data in OpenSSH or SECSH format Raises: ValueError: Unrecognised type of ssh key ValueError: No valid ssh keys found Returns: keys: A list of `Ssh2Key` objects \"\"\" lines = data . splitlines () # break the input into lines keys : \"List[Ssh2Key]\" = [] inside_keyblock = False # where we are keyblock : \"List[str]\" = [] keytype = \"\" pubpriv = \"\" for line in lines : matches = KEY_BOUNDARY_PATTERN . match ( line ) if inside_keyblock and matches and matches . group ( \"beginend\" ) == \"END\" : inside_keyblock = False # no longer within a keyblock if keytype == matches . group ( \"keytype\" ) and pubpriv == matches . group ( \"pubpriv\" , ): if keytype in [ \"OPENSSH\" , \"DSA\" , \"EC\" , \"RSA\" ]: key = cls . _parse_openssh ( keyblock , keytype , pubpriv ) elif keytype == \"SSH2\" : key = cls . _parse_secsh ( keyblock , pubpriv ) else : raise ValueError ( f \"Unrecognised type of ssh key { keytype } \" , ) if key : keys . append ( key ) elif inside_keyblock : keyblock . append ( line ) elif matches and matches . group ( \"beginend\" ) == \"BEGIN\" : keytype = matches . group ( \"keytype\" ) pubpriv = matches . group ( \"pubpriv\" ) inside_keyblock = True # inside a new keyblock else : # check for OpenSSH format -- all on one line matches = OPENSSH_PUBKEY_PATTERN . match ( line ) if matches : keys . append ( cls . _parse_openssh_oneline ( matches )) else : # raise ValueError(\"Unrecognised type of ssh key\") pass # ignore for now if len ( keys ) == 0 : raise ValueError ( \"No valid ssh keys found\" ) # return the assemblage of keys return keys","title":"parse()"},{"location":"library/#ssh2_parse_key.ssh2_parse_key.Ssh2Key.parse_file","text":"Creates a set of Ssh2Key objects from a file of ssh key data Accepts a block of text containing SSH2 public keys (in either OpenSSH or SECSH format) and parses out SSH2 public keys returning them as Ssh2Key Objects. Parameters: Name Type Description Default filepath PathLike[str] Pathname of a file of ssh key data in OpenSSH or SECSH format required Exceptions: Type Description IOError From underlying open/read ValueError Unrecognised type of ssh key ValueError No valid ssh keys found Returns: Type Description List[Ssh2Key] keys: A list of Ssh2Key objects Source code in ssh2_parse_key/ssh2_parse_key.py @classmethod def parse_file ( cls , filepath : \"PathLike[str]\" ) -> \"List[Ssh2Key]\" : \"\"\" Creates a set of `Ssh2Key` objects from a file of ssh key data Accepts a block of text containing SSH2 public keys (in either OpenSSH or SECSH format) and parses out SSH2 public keys returning them as `Ssh2Key` Objects. Arguments: filepath: Pathname of a file of ssh key data in OpenSSH or SECSH format Raises: IOError: From underlying open/read ValueError: Unrecognised type of ssh key ValueError: No valid ssh keys found Returns: keys: A list of `Ssh2Key` objects \"\"\" with open ( filepath ) as f : data = f . read () return cls . parse ( data )","title":"parse_file()"},{"location":"library/#ssh2_parse_key.ssh2_parse_key.Ssh2Key.rfc4716","text":"Returns an SSH public key in SECSH format (as specified in RFC4716). Preserves headers and the order of headers. Returned as a single string including newlines and with terminating newline. Alias - rfc4716() just calls secsh() See http://tools.ietf.org/html/rfc4716 Exceptions: Type Description ValueError Unable to output secsh format private keys Returns: Type Description str string: Single secsh key as a string including newlines and with terminating newline. Source code in ssh2_parse_key/ssh2_parse_key.py def rfc4716 ( self ) -> str : \"\"\" Returns an SSH public key in SECSH format (as specified in RFC4716). Preserves headers and the order of headers. Returned as a single string including newlines and with terminating newline. Alias - ``rfc4716()`` just calls ``secsh()`` See http://tools.ietf.org/html/rfc4716 Arguments: Raises: ValueError: Unable to output secsh format private keys Returns: string: Single secsh key as a string including newlines and with terminating newline. \"\"\" return self . secsh ()","title":"rfc4716()"},{"location":"library/#ssh2_parse_key.ssh2_parse_key.Ssh2Key.secsh","text":"Returns an SSH public key in SECSH format (as specified in RFC4716). Preserves headers and the order of headers. Returned as a single string including newlines and with terminating newline. See http://tools.ietf.org/html/rfc4716 Exceptions: Type Description ValueError Unable to output secsh format private keys Returns: Type Description str string: Single secsh key as a string including newlines and with terminating newline. Source code in ssh2_parse_key/ssh2_parse_key.py def secsh ( self ) -> str : \"\"\" Returns an SSH public key in SECSH format (as specified in RFC4716). Preserves headers and the order of headers. Returned as a single string including newlines and with terminating newline. See http://tools.ietf.org/html/rfc4716 Arguments: Raises: ValueError: Unable to output secsh format private keys Returns: string: Single secsh key as a string including newlines and with terminating newline. \"\"\" lines : \"List[str]\" = [] if self . type == \"public\" : key_header_chunk = \"SSH2 PUBLIC KEY\" else : raise ValueError ( \"Unable to output secsh format private keys\" ) key_header_chunk = \"SSH2 ENCRYPTED PRIVATE KEY\" # add the wrapping header lines . append ( f \"---- BEGIN { key_header_chunk } ----\" ) # add the headers, if any if len ( self . headers ): for header , value in self . headers . items (): self . _encode_header ( lines , header , value , 74 ) # add the key content lines . extend ( textwrap . wrap ( self . key , 70 )) # add the wrapping footer lines . append ( f \"---- END { key_header_chunk } ----\" ) lines . append ( \"\" ) # force terminating newline # return the assembled string return \" \\n \" . join ( lines )","title":"secsh()"},{"location":"library/#ssh2_parse_key.ssh2_parse_key.Ssh2Key.subject","text":"Returns the subject header from a ssh key object. Returns: Type Description Union[str, None] string: Subject field or None . Source code in ssh2_parse_key/ssh2_parse_key.py def subject ( self ) -> \"typing.Union[str, None]\" : \"\"\" Returns the subject header from a ssh key object. Arguments: Returns: string: Subject field or `None`. \"\"\" if \"Subject\" in self . headers : return self . headers [ \"Subject\" ] return None","title":"subject()"},{"location":"license/","text":"MIT License Copyright (c) 2020, Nigel Metheringham Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"}]}